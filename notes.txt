Introduction
============

Gradel is build automation tool
comiple, then run the tests
package the compiled source into packages (jar, war)
deploy and run

gradle uses groovy or kotlyn for scrippting instead of XML

gradle allow customization on how dependencies are pulled (custom rules and custom rules)

incremental builds
build cache
daemon

to install gradle
https://gradle.org/install/

for windows use: gradlew.bat
for linux/mac: gradlew
=> w stands for "wrapper"

to make a folder a gradle project: gradle init

DSL: Domain Specific Language
we say, script DSP

gradle tasks tries to find and list and available tasks in build.gradle

to add a task:
task fistTask {
  //do something
}

using camel case allows you call the task in abrev mode
"gradle fistTask" OR "gradle fT"

gradlew file, is an executable => automatically installs gradle for the project, that way you do not need to to have a global version of gradle installed
also maintins its current version unless you update it
that way you have gradle per project
it uses the config from gradle/wrapper/gradle-wrapper.properties 

Creating a Java project
=======================
in build.gradle
include('app') => "app" name of the folder that contains src/main/... etc

gradle is not heavy
uses plugin "id 'application'" knows the tasks needed for a java project like
build, compile, generate jar, distribute as .zip... etc

gradle compileJava => generates the build folder
gradle clean => cleans/removes the build folder
gradle test => runs the unit tests

gradle test generates a summary report under: /app/build/reports/tests/test => contains an html files that shows the final report

This is how we tell gradle where the application's main method is
application {
    // Define the main class for the application.
    mainClass = 'com.bharath.gradle.App'
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
} => this is used to define which repositories shoud be searched when fetching dependencies

dependencies {
    // Use JUnit test framework.
    testImplementation 'junit:junit:4.13.2'

    // This dependency is used by the application.
    implementation 'com.google.guava:guava:31.0.1-jre' => makes the application use this JRE instead of the system JRE which makes things more stable, if removed, the app will use the system's JRE
} => this is used to specify dependencies

implementation 'com.google.guava:guava:31.0.1-jre'
com.google.guava => groupID
guava => artifactID
31.0.1-jre => Version
implementation => the scope or configurations (app vs test)

repositories can also be custom configured
repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral{
      url = "..."
    }
}
as typically, organizations have their own repositories 

we also have mavenLocal()
this points to ~/.m2 => in case you have maven installed on your machine
it contains all the dependencies that have already been pulled by other projects that use maven instead of gradle
as for gradle dependencies, they are downloaded into .gradle/caches/modules-X/files-X.Y

The repositories as searched in the order they are defined

implementation and testImplementation come with the java pluggin
they allow one to control which dependencies reach the final jar/war file

Configurations
==============
gradle provides granular control
implementation
testImplementation
comipleOnly
runtimeOnly
testComipleOnly
... etc

compile => can cause leaks of dependencies from one project to another in case on project had the other as a dependency

Gradle Phases
=============
Iinitializations
Configuration
Execution

doFirst / doLast

println 'gradle rocks!!' => runs in configuration phase
task firstTask {
  println 'gradle rocks!' => runs in configuration phase
  doFirst(){
    println 'first' => runs in execution phase
  }
  doLast(){
    println 'last' runs in execution phase
  }
}

using --daemon => from 2nd build and up, the build become faster
the daemon caches build infromation in memory
--no--daemon => forces gradle not to use daemon

Goovy crash course
==================
Goovy can be ran as a script without a main() method

Declaring variables:
1) inside main method: you must specify the variable's type: String s = "hello"
2) as a script wihout a main method, you do not need to sepcify the type: s = "hello"
you can also use "${s}" => this will replace $s with the value of s

for strings, single and double quotes can be used

Also multiple line Strings can be used:
S = '''
hello,
my name is groovy
!!
'''

groovy script regular expression
emailPatern = /^\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,3}$/
print "test@gmail.com" ==~ emailPatern

==~ this is called the find/pattern operator

a.class => get the class type of a variable

vairables can also be defined using "def"
def u = "james"
def i = 1
but this is not recommended

Closure:
--------
c = {
    println("hello")
}

and then you invoke using .call: c.call()

parameters can be passed to closures as well:
j = { n ->
    println(n % 2 == 0 ? "even" : "odd")
}

j = { x, y, n ->
    println(n % 2 == 0 ? "even" : "odd")
}

or with default value
j = { n = 2 ->
    println(n % 2 == 0 ? "even" : "odd")
}

iterators with closures:
4.times {n->println n} => iterates on 4 (0->3) and passes it as an input argument to the closure
4.times {println it} => iterates on 4 (0->3) and prints the object being iterated on
it => a keyword in groovy that denotes the object (something similar to "this")

Collections
-----------
l = [1,2,3]
l << 4 => shift left operator, appends to list
l = l + [5,6] => append another list to the list
l = l - [3,2] => remove items from the list

some operations that can be done on lists
l.each {println(it)}
l.eachPermutation {println(it)}
l.reverseEach {println(it)}

Sets and Maps
-------------
s = ["java", "python", "js", "python"] as Set
sets do filter out duplicates

m = [james:"nounou", wiki:"susu", jiji:345]
looping over map elements
m.each {k, v ->
    println(k + ' / ' + v)
}


Methods
-------
int product(int x, int y) {
    return x*y
}

def product2(x,y) {
    x*y => the last line becomes the return statement
}

to call the methods:
product(2, 4)
result = product2 2, 4

int product3(int x = 3, int y) { => you can set default values
    return x*y
}

the syntax below also works and is used with gradle build files
void displayMap (Map productDetails){
    println productDetails.name
    println productDetails.price
}

displayMap name:"hello",price:50
displayMap(name:"hello",price:50)
displayMap([name:"hello",price:50])

Classes
-------
class Patient {
    def firstName, lastName, age

    // this setter method overrides default setter methods
    void setLastName(lastName){
        if (lastName == null){
            throw new IllegalArgumentException("Last Name can not be null!")
        }
        this.lastName = lastName
    }
}

p2 = new Patient(firstName: "john", lastName: "billo", age: 16)

Static methods and vairables can eb defined as well and accessed using the class name like in Java


Gradle Build files
===================
repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

repositories is infact a method on the "project" Object to which we are passing a closure

repositories ({
    // Use Maven Central for resolving dependencies.
    mavenCentral()
})

---------------

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
}

repositories {
    // value of name comes from file settings.gradle, these are project properties, more can be found at
    // https://docs.gradle.org/current/userguide/writing_build_scripts.html
    println project.name
    println project.description
    println project.version
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

if we want to set some values, we will have to do them after the plugins{...} method

when a version is defined and the project rebuilt, we will see a new jar file in app/build/libs with the version as part of the name

adding custom properties:
project.ext.xyz = "hello"
then when using it inside a method: project.xyz or project.property("xyz")

Tasks
-----
gradle has in built tasks, also some come with the java and application pluggins

task (firstTask) {
  // do something
}

OR

task firstTask {
  // do something
}

task => method on the project object, project.task(){...}
the {...} is the action block, we can have doLast({...})
the action block is a closure we are passing

anything outside doFirst() and doLast() will run in configuration phase and not in "task" phase

tasks can also be made to depend on each other
deployToStage.dependsOn deployToProd => makes deployToProd run before deployToStage
deployToProd.finalizedBy cleanUpFiles => makes cleanUpFiles run directly after deployToProd


also tasks can be set as defaults:
defaultTasks "deployToProd" => you call gradle without arguments from the terminal